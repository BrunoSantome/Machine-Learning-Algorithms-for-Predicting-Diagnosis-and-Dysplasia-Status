# -*- coding: utf-8 -*-
"""ANN_Dsyplasia.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dHIH05h20iKZ_Q1pPFZfinli1Av6yqp4
"""

#Description: This program classifies patients as having chronic kodney disease (ckkd) or not
#             using Artifical Neural Networks (ANN)

#import libraries
import glob 
from keras.models import Sequential, load_model
import numpy as np
import pandas as pd
from keras.layers import Dense
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
import matplotlib.pyplot as plt
import keras as k

#load the data
from google.colab import files
uploaded = files.upload()

df = pd.read_csv('dataset.csv',sep=';')

#print the first 5 rows
df.head()

#get the shape of the data (the number of rows and columns)
df.shape

#create a list of column names to keep
columns_to_retain = ['Homogene', 'Reticulated', 'Age', 'Sex', 'Tobacco', 'Stupefies', 'Alcohol', 'Diagnosis', 'Dysplasia']

#drop the columns that are not in columns_to_retain
df = df.drop( [col for col in df.columns if not col in columns_to_retain], axis=1 )

#drop the rows with na or missing values
df = df.dropna(axis=0)
df.tail()

#transfrom the non-numeric data in the columns

for column in df.columns:
  if df[column].dtype == np.number:
    continue
  else:
    df[column] = LabelEncoder().fit_transform( df[column])

#print the first 5 rows of the new clean dataset
df.head()

#split the data into independent (x) dataset (the features) and dependent (y) dataset (the target)
#X = df.drop(['Dysplasia'], axis=1)
#y = df['Dysplasia']
X = df.drop(['Dysplasia'], axis=1)
y = df['Dysplasia']

#feature Scaling
#min-max Scaler method scales the datase so that all the input feature lie between 0 and 1
x_scaler =MinMaxScaler()
x_scaler.fit(X)
column_names = X.columns
X[column_names] = x_scaler.transform(X)

#split the data into 80% training and 20% testing & shuffle
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, shuffle=True)

#build the model
model = Sequential()
model.add( Dense(256, input_dim= len(X.columns) ,kernel_initializer= k.initializers.random_normal(seed=13), activation='relu'))
model.add( Dense(1, activation='hard_sigmoid') )

#compile the model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

#train the model
history = model.fit(X_train, y_train, epochs = 2000, batch_size= X_train.shape[0])

#save the model
score, acc = model.evaluate(X_test, y_test,
                            batch_size=10)
model.save('dysplasia.model')

#Visualize the model loss and accuracy
plt.plot(history.history['accuracy'])
plt.plot(history.history['loss'])
plt.title('model accuracy and loss')
plt.ylabel('accuracy and loss')
plt.xlabel('epoch')

#Get the shape of the training and testing data set
print('shape of training data:', X_train.shape)
print('shape of test data:', X_test.shape)

#to see the prediction if patients have dysplasia or not
#show the actual values and predicted values
pred = model.predict(X_test)
pred = [1 if y>=0.5 else 0 for y in pred]
pred

print('Original :{0}'.format(",".join(str(x) for x in y_test)))
print('Predicted :{0}'.format(",".join(str(x) for x in pred)))

#if patients has Dysplasia or not
y_test